# claire-protorpc Tutorial

This tutorial provide an overview of claire-protorpc server and client.

For fully functional examples claire-protorpc demo servers and clients, please refer to the examples directories in the claire-protorpc distributions.

Let's start with an examples of a  claire-protorpc client communicating with a claire-protorpc server.

## Define a Protocol Buffers interface ##

The first thing we will need is a Protocol Buffers interface, to describe the interaction between the client and the server.

Protocol Buffers provides a simple language for defining message types and services. We won't cover the details of this language here, as it's features are well documented on the Protocol Buffers website. For the purposes of this tutorial, we want to define a service with a single method, that executes a echo request and returns echo response.

Protocol Buffers messages and services are defined in .proto files. The following file, named echo.proto, defines a service named Echo, with associated EchoRequest and Echo Response message types :

    // echo.proto
    package echo;

    option cc_generic_services = true;

    message EchoRequest {
        required string str = 1;
    }

    message EchoResponse {
        required string str = 1;
    }

    service EchoService {
        rpc Echo (EchoRequest) returns (EchoResponse);
    }

To make use of this interface in our program, we first need to use the Protocol Buffers compiler, protoc, to generate the source code corresponding to the interface. Google suggest RPC implementions "provide code generator plugins which generate code specific to the particular RPC implementation.", and claire-protorpc provide a plugin called "protoc-rpc-gen", which will be installed when use install claire-protorpc library.
So we instruct protoc to generate C++ source code like :

    protoc --plugin=protoc-rpc-gen --rpc_out . echo.proto

This will produce two files, echo.pb.cc and Tutorial.pb.h, in the same directory as echo.proto. echo.pb.h provides C++ definitions of message and service types, and will be included into our source code. echo.pb.cc provides the corresponding source code for the message and service types, and needs to be compiled into both the server and the client.

Beacaure we use claire-protorpc version service.h, so you must run such command before compile protoc generated code:

    sed -i "s/#include <google\\/protobuf\\/service.h>/#include <claire\\/protorpc\\/service.h>/" echo.pb.h

Usually you can do it automatically.

## C++ Server ##

Server-side should implement the service, and register it to RpcServer object

    #include <echo.pb.h>
    
    #include <boost/bind.hpp>
    
    #include <claire/protorpc/RpcServer.h>
    #include <claire/common/events/EventLoop.h>
    #include <claire/common/logging/Logging.h>
    #include <claire/netty/InetAddress.h>
    
    using namespace claire;
    using namespace claire::protorpc;
    
    DEFINE_int32(num_threads, 4, "num of RpcServer threads");
    
    namespace echo
    {
    
    class EchoServiceImpl : public EchoService
    {
    public:
        virtual void Echo(RpcControllerPtr& controller,
                          const ::echo::EchoRequestPtr& request,
                          const ::echo::EchoResponse* responseProtoType,
                          const RpcDoneCallback& done)
        {
            EchoResponse response;
            response.set_str(request->str());
            done(controller, &response);
        }
    };
    
    } // namespace echo
    
    int main(int argc, char* argv[])
    {
        ::google::ParseCommandLineFlags(&argc, &argv, true);
        InitClaireLogging(argv[0]);
    
        EventLoop loop;
        InetAddress listen_address(8080);
        echo::EchoServiceImpl impl;
        RpcServer server(&loop, listen_address);
        server.set_num_threads(FLAGS_num_threads);
        server.RegisterService(&impl);
        server.Start();
        loop.loop();
    }

Let's step through this line by line.

We need to include the generated Protocol Buffers headers:

    #include <echo.pb.h>

Then we need to include claire-protorpc headers:

    #include <claire/protorpc/RpcServer.h>

EchoService is an abstract interface class generated by Protocol Buffers. Our implementation must derive from this class, and implement the Echo() method:

    class EchoServiceImpl : public EchoService
    {
    public:
        virtual void Echo(RpcControllerPtr& controller,
                          const ::echo::EchoRequestPtr& request,
                          const ::echo::EchoResponse* responseProtoType,
                          const RpcDoneCallback& done)
        {
            EchoResponse response;
            response.set_str(request->str());
            done(controller, &response);
        }
    };

claire-protorpc do not use Google defined RpcController and Closure class, but use self defined RpcController and boost::bind replaced. The benifit is claire-protorpc can use a single namespace claire and many modern c++ feature since TR1.Besides, claire-protorpc use smart pointer manage resource, library user do not care about it. The 3rd parameter always no use for library user, only remind user should use the right response type only.

RpcContorller allow us to control the server-side execution of a remote call. For a simple implementation like this one, it's enough to call done at the bottom of the implementation function, to signal that the response is ready to be sent back to the client:

            done(controller, &response);

In main, we create the server, and pass in the endpoint we want to the server to listen on:

        RpcServer server(&loop, listen_address);

We register our EchoService implementation to the server:

        echo::EchoServiceImpl impl;
        server.RegisterService(&impl);

Finally, we start the server and wait for clients to call in:

        server.Start();
        loop.loop();

Here we a eventloop drive the process, which like libev/libevent reactor model.

## C++ client  ##

Client-side do not need user implement anything, but has more concept:

    #include <examples/rpcbench/echo.pb.h>
    
    #include <boost/bind.hpp>
    #include <boost/noncopyable.hpp>
    #include <boost/ptr_container/ptr_vector.hpp>
    
    #include <claire/common/threading/CountDownLatch.h>
    #include <claire/common/logging/Logging.h>
    #include <claire/common/eventloop/EventLoop.h>
    #include <claire/common/eventloop/EventLoopThread.h>
    #include <claire/common/eventloop/EventLoopThreadPool.h>
    #include <claire/netty/InetAddress.h>
    
    #include <claire/protorpc/RpcChannel.h>
    
    using namespace claire;
    using namespace claire::protorpc;
    
    void replied(RpcControllerPtr& controller, const boost::shared_ptr<echo::EchoResponse>& resp)
    {
        if (controller->Failed())
        {
           LOG(ERROR) << controller->ErrorText();
        }    
        LOG(INFO) << "Request complete: " << resp.str();
    }
        
    int main(int argc, char* argv[])
    {
        EventLoop loop;
    
        InetAddress server_address(argv[1], 8080);
        RpcChannel channel(&loop);
        channel.Connect(server_address);

        echo::EchoService::Stub stub(&channel);
        RpcControllerPtr controller(new RpcController());
            
        echo::EchoRequest request;
        request.set_str("0123456789ABCDEF");
        stub.Echo(controller, request, boost::bind(&replied, _1, _2));

        loop.loop();
    }

Let's step through this line by line.

We need to include the generated Protocol Buffers headers:

    #include <echo.pb.h>

Then we need to include claire-protorpc headers:

    #include <claire/protorpc/RpcChannel.h>

In main, we define a RpcChannel first,  it communicate with server-side, Connect() is non-block fuctions.

        InetAddress server_address(argv[1], 8080);
        RpcChannel channel(&loop);
        channel.Connect(server_address);

Protocol Buffers has generated a service stub type, which we instantiate:

        echo::EchoService::Stub stub(&channel);

Protocol Buffers has defined the EchoRequest and SearchResponse classes for us. We create a EchoRequest object:

        echo::EchoRequest request;
        request.set_str("0123456789ABCDEF");

Protocol Buffers generates a service stub that can function asynchronously:

        stub.Echo(controller, request, boost::bind(&replied, _1, _2));

When response received, the replied() function will be called.

  [1]: https://code.google.com/p/protobuf/
